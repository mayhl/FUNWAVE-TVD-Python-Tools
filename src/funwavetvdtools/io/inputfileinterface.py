import json
from abc import ABC, abstractmethod

from funwavetvdtools.error import FunException
from funwavetvdtools.io.parameter import Category, Parameter
from funwavetvdtools.misc.justifylines import JustifyLines


class InputFileInterface(ABC):

    #__slots__ = ('_parameters', '_categories')
 
    """
    Base class defining core functionality for derivied class. Derivied class
    implements abstract method __add_parameters__(self) defining all parameters,
    e.g., self._NAME = Parameter(NAME, ...). Getter and setters are used to provide
    quicker access to parameters values, e.g., self.parameters[NAME].value vs self.NAME.

    :param values: Keyword arguments of to initialize parameter values with.
    """

    __slots__ = ('_parameters', '_categories')
    def __init__(self, **values):

        
        self._parameters = {}
        self._categories = {}

        # Abstract function to be implemented in derived class.
        # Definition of parameters, e.g., self._NAME = Parameter(NAME, ...)
        self.__add_parameters__()

        # Initializing dependencies links
        for _, p in self._parameters.items():
            p._link_dependencies(self._parameters)

        # Setting parameter values is defined 
        if len(values) > 0: self.set_values(**values)

    
    @classmethod
    def _get_doc_string(cls, dt_stamp):
    
        return """Class handling FUNWAVE input/driver files. 
                Autogenerated on %s 
                """ % dt_stamp


    @classmethod
    def _get_slots(cls, slots):
        """
        Wrapper function for adding base (this) class slots to derived class

        :param slots: Tuple of derived class slots
        :type slots: tuple(str)
        """ 
        slots = tuple( "_%s" % slot for slot in slots)
        return cls.__slots__ + slots

    @abstractmethod
    def __add_parameters__(self):
        """
        Abtract method to implement in derived class defining Parameter as attributes  
        """


    def set_values(self, **values):
        """
        Set parameter values 
        
        :param values: Test
        :type values:
        """
        for param in values: 
            if not hasattr(self, param):
                msg = "Parameter '%s' is not defined in class."
                raise FunException(msg, AttributeError)
            setattr(self, param, values[param])    


    # Parameter initalization and checks 
    def _add_parameter(self, param):
        
        name = param.name
        if param.name in self._parameters.keys():
            msg = "FATAL: Parameter has already been added!!!"
            raise FunException(msg, AttributeError)

        catgy = param.category
        if not catgy in self._categories.keys():
            self._categories[catgy] = {}

        if name in self._categories[catgy].keys():
            msg = "FATAL: Parameter has already been added to category '%s'!!!" % catgy
            raise FunException(msg, AttributeError)

        self._parameters[name] = param
        self._categories[catgy][name] = param

    # Inserting additional initalization when adding new attribute of type Parameter
    def __setattr__(self, name, value):
        if type(value) is Parameter: self._add_parameter(value)
        super().__setattr__(name, value)

    def at(self, names):
        """
        Get parameter(s) as list by name(s)

        :param names: Parameters name or list of Parameter names to retrieve
        :type names: str, list[str]
        """
        if type(names) is str: return self._parameters[names]
        return [self._parameters[n] for n in names]
    
    @property
    def parameters(self):
        """
        Return dictionary of parameters
        """
        return self._parameters

    @property
    def categories(self):
        """
        Return nested dictionary of categories and corrosponding parameters.
        """
        return self._categories

    def _filter(self, is_minimal=True, is_grouped=False, modules=None):
        
        def add(mdl, param):      
            lst.append(param if not is_grouped else (mdl, param))

        lst = []

        # Adding central module parameters if marked as minimal (see Parameter.is_minimal),
        # or in full mode, i.e., is_minimal=False 
        for mdl in Category:
            if not mdl in self.categories: continue
            if not mdl.is_essential: continue 

            for name in self.categories[mdl]:
                param = self.categories[mdl][name]
                if not is_minimal or param.is_minimal: add(mdl, param)
   
        
        if modules is None: modules = [] 
        # Filtering out central modules
        modules = [mdl for mdl in modules if not mdl.is_essential] 

    
        # Adding non-central modules with parameters that have been set 
        for mdl in Category:
            if not mdl in self.categories: continue
            if mdl.is_essential: continue

            for name in self.categories[mdl]:
                param = self.categories[mdl][name]
                if param.is_set: 
                    if not mdl in modules: modules.append(mdl)
                    break    

        # Add all parameters for marked non-central modules
        for mdl in modules:
            for param in self.categories[mdl]: add(mdl, param)


        return lst
            
    def to_list(self, is_minimal=True, is_grouped=False, modules=None):
        """
        Get list of parameters

        :param is_minimal: Return minimal amount of parameters required start FUNWAVE simulations.
        :type is_minimal: bool
        :param is_grouped: False - Return list of Parameters. True - Return list of (Category, Parameter) pairs/tuples. 
        :type is_grouped: bool 
        """
        
        return self._filter(is_minimal, is_grouped, modules)


    def to_dict(self, is_minimal=True, is_grouped=False, is_detailed=False, modules=None):
        """
        Converts parameters into dictionary keyed by parameter name 

        :param is_minimal: Return minimal amount of parameters required start FUNWAVE simulations.
        :type is_minimal: bool
        :param is_grouped: Group parameters into sub dictionaries according to Category. 
        :type is_grouped: bool
        :param is_detailed: False - Dictionary value is parameter value. True - Dictionary value is a dictionary of Parameter properties.
        :type is_detailed: bool
        :param modules: Additional non essential module/Category to include in output
        :type modules: list[Category]
        """
        lst = self.to_list(is_minimal, is_grouped, modules)

        print(lst)
        def get_value(p):
            return p.to_dict() if is_detailed else p.value

        if is_grouped:  

            d = {}
            for mdl, param in lst:
                if not mdl in d: d[mdl] = {}
                d[mdl][param.name] = get_value(param)

            return d  

        else:
            return {p.name: get_value(p) for p in lst}

    @classmethod
    def from_dict(cls, d):
        """
        Initialize Parameter object with values define in dictionary.

        :param d: Dictionary with key/value pairs corrosponding to paramater name/value pairs.
        :type d: dict
        """
        # Checking if dict is group by Category 
        is_grouped = True
        for k in d: 
            if not k in Category:
                is_grouped = False
                break
        
        # Unwrapping Categories if present 
        if is_grouped:

            tmp_d = {}
            for mdl in d: tmp_d.updates({p: d[mdl][p] for p in d[mdl]})
            d = tmp_d
        
        def get_val(p):
            return p.value if type(p) is dict else p

        d = {p: get_val(p) for p in d} 

        # Initializing class with read parameters     
        return cls(**d) 

    def to_json(self, fpath, is_minimal=True, is_grouped=False, is_detailed=False, modules=None, **json_args):
        """
        Dumps parameter name, value pairs as JSON file"

        :param json_args: Optional arguments for json.dump function, see https://docs.python.org/3/library/json.html#basic-usage.
        """
        with open(fpath, 'w') as fh:
            lst = self.to_dict(is_minimal, is_grouped, is_detailed, modules)
            json.dump(lst, fp=fh, **json_args)


    @classmethod
    def from_json(cls, fpath):
        """ 
        Initialize Parameter object with parameters values in JSON file
        
        :param fpath: Path to JSON file
        :type fpath: str
        """ 
        with open(fpath, 'r') as fh:
            return cls.from_dict(json.load(fh))


    def to_input(self, fpath, is_minimal=True, modules=None, with_desc=False, width=40, banner_char='-'):
        """
        Write FUNWAVE compatible input/driver file

        :param fpath: Path to output input/driver file
        :type fpath: str
        :param is_minimal: Return minimal amount of parameters required start FUNWAVE simulations.
        :type is_minimal: bool
        :param modules: Additional non essential module/Category to include in output
        :type modules: list[Category]
        :param with_desc: Add parameter descriptions to output 
        :type with_desc: bool 
        """

        # Getting parameters
        is_grouped = True
        lst = self.to_list(is_minimal, is_grouped, modules)
        
        # Filtering out flag parameters
        lst = [(mdl, p) for mdl, p in lst if not p.is_flag]
        
        jlines = JustifyLines(['l', 'l'], seperators=' = ')
        old_mdl, _ = lst[0]
        new_mdl = old_mdl 
        params = []

 
        def write_banner(title=None):

            nonlocal banner_char, width
            banner = ''.join([banner_char]*width)
            if title is None: fh.write(banner + "\n")

            title = title.strip()
            n = width - len(title) - 2

            n2 = n//2
            n1 = n - n2

            fmt_title  = ''.join([banner_char]*n1)
            fmt_title += ' ' + title + ' '
            fmt_title += ''.join([banner_char]*n2)

            fh.write("# " + banner + "\n")
            fh.write("# " + fmt_title + "\n")
            fh.write("# " + banner + "\n")
             
        def flush_category():
            
            nonlocal old_mdl, new_mdl, params, jlines
            write_banner(old_mdl.name)    

            if with_desc: 
                for *_, desc in params:

                    write_banner()
                    raise NotImplementedError()

            for name, value, *_ in params: jlines.append([name, value])

            for line, (_, _, is_comment, _) in zip(jlines.to_formatted_lines(), params):
                if is_comment: line = "# " + line
                fh.write(line + "\n")

            fh.write("\n")

            jlines.clear()
            old_mdl = new_mdl
            params = []

        with open(fpath, 'w') as fh:

            for new_mdl, p in lst:    
                if not old_mdl == new_mdl: flush_category()

                desc = None if not with_desc else p.description
                is_comment = not new_mdl.is_essential and not p.is_set
                params.append((p.name, p.value_to_string(), is_comment, desc))
            
            flush_category()    
                


    @classmethod
    def from_input_to_dict(cls, fpath):
        """
        Convert FUNWAVE input/driver file to dictionary

        :param fpath: Path to FUNWAVE input/driver file
        :type fpath: str
        """

        def _split_first(line, char):

            first, *second = line.split(char)
            second = char.join(second)
            return first, second 

        def _filter_comment(line):

            if "!" not in line: return False, line, None 
            first, second = _split_first(line, "!")
            return True, first, second 


        with open(fpath, 'r') as fh: lines = fh.readlines()

        params = {}
        for line in lines: 

            if not '=' in line: continue
            first, second = _split_first(line, "=")        

            is_comment, name, _  = _filter_comment(first.strip())
            if is_comment: continue

            is_comment, val_str, _ = _filter_comment(second.strip())
            params[name] = val_str

        return params                 

    @classmethod
    def from_input(cls, fpath):
        """ 
        Initialize Parameter object with parameters values in FUNWAVE input/driver file
        
        :param fpath: Path to FUNWAVE input/driver file 
        :type fpath: str
        """
        return cls(**cls.from_input_to_dict(fpath))
 


 
    
